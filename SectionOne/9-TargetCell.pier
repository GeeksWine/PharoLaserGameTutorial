! Enhancing TargetCell

% http://squeak.preeminent.org/tut2007/html/029.html

A target cell is the last one of our cells. It is unique because it does not have exit. Once the laser beam enters a target cell it does not leave and propagate anymore. A design choice we made here is to set the exit values to be nil. But let us start by writing some tests to clarify what we mean.


!! Adding a class comment

Let us start to add a class comment. We propose something like the following.

[[[
A target cell is a cell does not let the beam leave once entered. Once a target is reached the game is finished. 
]]]


!! Adding Some Tests

% http://squeak.preeminent.org/tut2007/html/030.html

Let us follow our good practices and add some tests.

We add a new test class named ==TargetCellTest==

[[[
TestCase subclass: #TargetCellTest
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Tests'
]]]

At creation time the cell should be off.

[[[
TargetCellTest>>testCellStateShouldBeOff
	| cell |
	cell := TargetCell new.
	self assert: cell isOff.
	self deny: cell isOn
]]]

All its segments should be off too. 

[[[
TargetCellTest>>testSegmentAtCreationShouldBeOff

	| cell |
	cell := TargetCell new.
	self deny: (cell isSegmentOnFor: #north).
	self deny: (cell isSegmentOnFor: #south).
	self deny: (cell isSegmentOnFor: #west).
	self deny: (cell isSegmentOnFor: #east).
]]]


 The ==testCellLaserActivitytestLaserEntersNorthShouldNotLitUpSouth== 
method should only find one segment lit-up when the laser beam enters.


[[[
TargetCellTest>>testLaserEntersNorthShouldNotLitUpSouth

	| cell |
	cell := TargetCell new.
	cell laserEntersFrom: #north.
	self assert: ( cell isOn ).
	self assert: (cell isSegmentOnFor: #north).
	self deny: (cell isSegmentOnFor: #south).
	self deny: (cell isSegmentOnFor: #west).
	self deny: (cell isSegmentOnFor: #east).
]]]



Now we express that all the exit sides of a target will be nil. 

[[[
TargetCellTest>>testCellExitsAreNil

	| cell |
	cell := TargetCell new.
	#(north #east #south #west)
		do: [ :inputSide | self assert: (cell exitFor: inputSide) isNil ]
]]]

!! Defining the corresponding behavior
Now we are ready to define all the behavior we wrote tests for. 

!!! TargetCell is a Cell

The first thing we will do is to make ==TargetCell== inherits from ==Cell==. Do it and you should get an hierarchy as shown by Figure *TargetCellInheritance*.


[[[ 
Cell subclass: #MTargetCell
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]


+TargetCell should also inherit from Cell.>file://figures/9-TargetCellInheritance.pdf|width=60|label=TargetCellInheritance+


Start to run the tests. Normally two not related to exit faces should already pass.


!!! Handling Exits

Now we should handle exit side. We redefine the ==initializeExitSides== as follows: 


[[[
TargetCell>>initializeExitSides

	self exitSides: Dictionary new.
	self exitSides at: #north put: nil.
	self exitSides at: #east put: nil.
	self exitSides at: #south put: nil.
	self exitSides at: #west put: nil.
	
]]]


And again we should define the method ==initialize== as follows. 

[[[TargetCell>>initialize

	super initialize.
	self initializeExitSides
]]]

Run the tests and they should all be green. This is clearly a good occasion to save your code. 


!! About Design Points

!!! About our initialize methods

It looks like we already defined this method several times and exactly the same. This is clearly a sign that we can do better. In the literature this is called a code smell (with the idea that bad code smells rotten parfums). Propose a solution to this problem without readin ours.

Our solution is the following one: we remove ==	self exitSides: Dictionary new.== from the ==initializeExitSides== and move it to the superclass ==initialize== method.

[[[
Cell>>initialize

	super initialize.
	self initializeActiveSegments.
	self exitSides: Dictionary new.
	self initializeExitSides.

Cell>>initializeExitSides
	"does nothing"
]]]

[[[
BlankCell>>initializeExitSides

	self exitSides at: #north put: #south.
	self exitSides at: #south put: #north.
	self exitSides at: #east put: #west.
	self exitSides at: #west put: #east
]]]

And we can now remove the initialize methods of ==BlankCell==. 

[[[
MirrorCell>>initialize
	super initialize.
	self leanLeft
]]]

And we can remove the method ==initializeExitSides== from MirrorCell since it is a copy of its superclass.

[[[
TargetCell>>initializeExitSides

	self exitSides at: #north put: nil.
	self exitSides at: #east put: nil.
	self exitSides at: #south put: nil.
	self exitSides at: #west put: nil.
]]]
And we can remove the initialize method of ==TargetCell==. 

Now we can run again our tests. And we can safely save a new version.

!!! About TargetCell Design

Using ==nil== to encode that there is no value for the exitSide is not an optimal way. Why? because it may force the client code to always check 
if it gets true, false or nil. Good object-oriented design is often to have an object accepting the same messages but doing nothing. It is called the ==NullObject== design pattern. What is nice is that it eliminates all the ==ifNil:== tests and follow the "tell don't ask" way of really thinking object-oriented programming. 

We will let the use of ==nil== right now but remember it in the future and a good exercise is to propose a new version without this encoding.





























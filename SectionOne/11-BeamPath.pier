
% Left out "Leaving Notes in Your Code" from original,
% http://squeak.preeminent.org/tut2007/html/035B.html 
% http://squeak.preeminent.org/tut2007/html/035C.html 

! Leaving Notes in Your Code

http://squeak.preeminent.org/tut2007/html/035B.html 

@@todo BTC-2014-07-06 Is this section of original tutorial left out on purpose?


! Improving Our Debugging Context

% This section is new.

Dealing with ==a Grid== in the debugger is a bit a pain because we don't yet have a graphical representation of it. In addition, when such graphical representations are broken, they cannot be used to debug themselves.  So a fallback representation is useful for observing the structure of ==a Grid==. 
The system tools have the convention of asking objects for their textual representation via the object's ==printString== method.   Following this convention will help us debug and observe how the system it is working. 


Here is a test showing the behavior that we want to start with. We test the output for an empty grid. We use ' x ' to make sure that
the character is well centered. Now pay attention that spaces are representated differently between text editors. Therefore you may have a different look.

% BTC-2014-07-08 Ahh, Steph. Now I guess why you changed the default grid size
% from 1x1 to 5x5, and I had changed it 3x3 with knowing it impacted here. 
% Well my 3x3 change was already integrated, so I propogate this here.
[[[
GridTest>>testTextualRepresentationEmptyGrid

	self assert: Grid new printString = 
'
| x | x | x |
| x | x | x |
| x | x | x |
'
]]]

The ==printString== method ends up calling its object's ==printOn:== method to generate the textual representation.  Below is one possible implementation. 
Again try to define it alone and follow our definition if you encounter
difficulties.  Note the common practice of putting a test expression in 
comments the top of the method, which you can select and ''Inspect''.

@@dothis On the class ==Grid== define the method ==printOn:== in the  'printing' protocol. 

% BTC-2014-07-06 Leaving a trailing space on each line (per previous code)
% is awkward and non-inutitive, and hard to capture in a printed page.
% Its better to be more explicit by using ==space==. 
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			aStream
				space;
				nextPutAll: 'x';
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]
% BTC-2014-07-06 aCol & aRow not suitable var names since Col and Row are not classes?

Run the test.  Now it can be tricky formatting the spaces exactly to satisfy 
the test, so you might get a "TestFailure: Assertion failed" error.  
In the debugger, inspect the line ==Grid new printString== to investigate.
Actually since this formatting is not really critical here, you might be 
pragmatic and paste the result of that inspection into ==testTextualRepresentationEmptyGrid==. 
% Otherwise it will be annoying that the reader works hard to get the 
% above test working with the 'x', and then need to replace it with space.


Now we would like the grid to display the type of cells. 
Do you have an idea how we could do that?
May be we could ask each cell its visual representation character instead of 
the =='x'== placeholder. We'll define a method named
==stringRepresentation== on the cell classes. We decided to use a string 
rather than a character to provide more flexibility to quickly change the
representation of a cell. Using a string implies that the representation 
can have a variable length.

% BTC-2014-07-06 I feel in this case the test is better written
% after-the-fact.  Is that really-bad?  I think its advtangeous to not
% be so proscriptive to the reader on Test Driven Development
% that they feel locked in.  Let them see a bit of flexibility. 


@@dothis Update the ==printOn:== method as follows, and add the placeholder ==stringRepresentation== ('printing' procotol).
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			| cell |
			cell := self at: col@row.
			aStream
				space;
				nextPutAll: cell stringRepresentation;
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]

[[[
Cell>>stringRepresentation
	^ 'x'.
]]]

Check you test is green. 

@@dothis Now add ==stringRepesentations== for the specific cell types, and modify/add tests to suit.

[[[
BlankCell>>stringRepresentation
	^ ' '   "There is one space character in the string."
]]]
[[[
GridTest>>testTextualRepresentationEmptyGrid
	"There are 3 space characters between the bars."
	self assert: Grid new printString = 
'
|   |   |   |
|   |   |   |
|   |   |   |
'  
]]]


[[[
TargetCell>>stringRepresentation

	^ 'o'
]]]
[[[
GridTest>>testTextualRepresentationGridWithTarget

	| grid |
	grid := Grid new  at: 3@1 put: TargetCell new.  
	self assert:  grid printString = 
'
|   |   | o |
|   |   |   |
|   |   |   |
'
]]]



[[[
MirrorCell>>stringRepresentation

	^ leansLeft ifTrue: ['\'] ifFalse: [ '/']
]]]
[[[
GridTest>>testTextualRepresentationGridWithMirror

	| grid |
	grid at: 1@1 put: MirrorCell leanLeft.
	grid at: 2@1put: MirrorCell leanRight.
	self assert:  grid printString = 
'
| \ | / |   |
|   |   |   |
|   |   |   |
'
]]]

Now since ==GridTest>>generateDemoGrid== is already defined, we can use that for  final test to validate overall behavior.

@@dothis Define a test for the textual representation of the demo grid.

[[[
GridTest>>testTextualRepresentation

	self assert: self generateDemoGrid printString = 
'
|   |   |   | / | o |
| / |   |   |   | \ |
|   | \ | / |   | \ |
|   | \ | \ |   |   |
| / |   |   | / |   |
'
]]]

@@todo Notice that it would be good to have also a class to represent ==StartingCell== like that we could add behavior to it.  
@@todo BTC-2014-07-06 Maybe, but need to finish the rest of the port, and see how it would fit. Maybe just advise reader to try it themselves.


! Laser Beam Path 

We are ready to work on the way to represent the laser beam and its path through the cells. Before jumping in the code let us think a bit about what we will need. We need to have a collection of elements describing the beam (probably such elements will be the basis to represent visually the beam when 
we will start adding visual elements). When the beam will exist to the east of a given cell we will need to know to which other cell it will enter.
This means that we will need a way to handle the cell locations and the interpretation of the direction based on such location. 



% http://squeak.preeminent.org/tut2007/html/036.html

!! Laser Path Element 
When we consider the path of the laser beam through the grid, it's pretty easy to imagine the path as an ordered collection. The elements in the path may not be strictly cells since we will need to be aware how the laser is entering each cell. Let us get started by defining a new class named ==LaserPathElement== to represent path element. 

Such element is bound to a given cell and an entry side, therefore we add the following instance variables to fully characterize an element. 

[[[
Object subclass: #LaserPathElement
	instanceVariableNames: 'cell entrySide'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

Add the corresponding accessors. 


!! Adding a Class Comment

So let us first add a class comment, for example as follows

[[[
I represent the part of a laser beam that is associated with a cell and with an entry side. 
]]]

!! Back to the Grid

Go back to the Grid and add an instance variable for the laser beam path and then add its accessors. We'll work out initialization in a few minutes.

[[[
Object subclass: #Grid
	instanceVariableNames: 'cells laserIsActive numberOfRows numberOfColumns laserBeamPath'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

We also need a method to answer the starting cell when the laser is activated. This will always be the cell in the bottom left corner.

[[[
Grid>startingCell

	^ self at: (1@ self numberOfRows)
]]]


!! Adding Location to Cell

To be able to compute from a cell and a direction its neighbouring cell we will enhance the cells. Each cell should store its own grid location. This will make navigation and position calculations easier. Without the stored location, we can still find specific cell locations within the grid by scanning through all the cells until we find the identical one we are looking for, then we would answer that cell's key (a position) in the cell dictionary. Holding the location within the cell is easier and much faster. 


Add the ==gridLocation== instance variable and its accessors.

[[[
Object subclass: #Cell
	instanceVariableNames: 'activeSegments exitSides gridLocation'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]


We should not forget to set the grid location to the cells when the grid adds the cell to its own structure. 
We modify then the method ==at:put:== of the class ==Grid== as follows:

[[[
Grid>>at: aPoint put: aCell

	aCell gridLocation: aPoint.
	self cells at: aPoint put: aCell.
]]]





!! Handling Directions

We've been using two kinds of systems to describe cell locations and laser beam direction. In one situation we use ==x\@y== (column x, row y) objects to describe where cells are located within the grid. We describe laser beam direction with the symbols ==\#north==, ==\#east==, ==\#south== and ==\#west==. We need a way to allow us to combine these concepts when we start to navigate our laser beam across the grid and through cells. 

Let us think about a solution: what would be good is to have objects that capture that for example going east is increasing of one the ==x== coordinates. If we are in cell ==5\@5== going east we should get to the cell ==6\@5==. Similarly going south is changing the y coordinates. 

A first reflex could be to write some conditions but we can do better. Indeed we do not want to have to have tests and conditionals and we can imagine that we can get different objects representing different directions and each one answering the delta that should be applied to get from one cell to the other one.

SD: should be better explained. It took me a while to understand it.

SD add a diagram explaining how to use Direction

For this we will create classes to represent the different direction and we will start by defining a common superclass named ==GridDirection==. We will then define a couple of messages on these classes. 

[[[
Object subclass: #GridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

And we can add a comment.

[[[
I represent directions for the beam path accross the grid cells.
]]]

+A hierarchy of directions.>file://figures/11-GridDirection.pdf|width=60|label=RowDebugPreview+

Then we can define one suclass for each direction as follows

[[[
GridDirection subclass: #EastGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #WestGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #NorthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #SouthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

You should obtain an inheritance hierarchy as described in *RowDebugPreview*.





Now for each subclasses, we can define some messages: the ==vector== which returns the delta from the cell to the direction and ==directionSymbol== which returns the symbol encoding the direction. 

For example we want to write 

[[[
SouthGridDirection directionSymbol
  -> #south
]]]


[[[
SouthGridDirection vector 
  -> 0@1

]]]

Since we want to ask the class for its encodings, we will define ''class'' methods on each subclasses as below.

[[[
EastGridDirection class>>vector
	^ 1 @ 0

EastGridDirection class>>directionSymbol
	^ #east
]]]




[[[
NorthGridDirection class>>vector
	^ 0 @ -1

NorthGridDirection class>>directionSymbol
	^ #north
]]]


[[[
SouthGridDirection class>>directionSymbol
	^ #south

SouthGridDirection class>>vector
	^ 0 @ 1
]]]


[[[
WestGridDirection class>>directionSymbol
	^ #west

WestGridDirection class>>vector
	^ - 1 @ 0
]]]



Now we can define a method named ==directionFor:== returning the class of the direction associated to directiondescribed by a symbol. 

[[[
GridDirection directionFor: #east
-> EastGridDirection
]]]

Here is the class method definition:

[[[
GridDirection class>>directionFor: aDirectionSymbol

	^ self subclasses 
			detect:  [ :cls | cls directionSymbol = aDirectionSymbol ]
]]]





!! Adding Some Tests

Now we need a unit test for the grid direction vector code. So let us add the new class ==GridDirectionTestCase== is a subclass of ==TestCase== of course.

[[[
TestCase subclass: #GridDirectionTest
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Tests'
]]]


[[[
GridDirectionTest>>testDirectionSelection
	| direction |
	direction := GridDirection directionFor: #north.
	self assert: direction = NorthGridDirection.
	self assert: direction vector = ( 0 @ -1 ).
	
	direction := GridDirection directionFor: #east.
	self assert: direction = EastGridDirection.
	self assert: direction vector = ( 1 @ 0 ).
	
	direction := GridDirection directionFor: #south.
	self assert: direction = SouthGridDirection.
	self assert: direction vector = ( 0 @ 1 ).
	
	direction := GridDirection directionFor: #west.
	self assert: direction = WestGridDirection.
	self assert: direction vector = ( -1 @ 0 ).
]]]


Once all the tests pass, it is a good time to publish your code.


!! Back to the Laser Beam Path


Now we are ready to work on laser path elements. Let us start to define a new class method that makes the creation of ==LaserPathElement== objects easier. Do you have any idea how to proceed? When we create a ==LaserPathElement== we should mention the cell it is acting on and also the side of the cells we are talking. 

[[[
LaserPathElement  class>>cell: aCell entrySide: aDirectionSymbol 

	| element |
	element := self basicNew.
	element 
		cell: aCell;
		entrySide: aDirectionSymbol.
	^ element
]]]


SD: add a test

We can also add another method taking a direction instead than a symbol. Objects are always more powerful than mere data so we should favor their use. 

[[[
LaserPathElement class>>cell: aCell entrySideDirection: aDirection

	^ self cell: aCell entrySide: aDirection directionSymbol
]]]


SD: add a test

A key functionality that we need is a method that given a path element answers the next cell on grid. Here we will clearly see the importance of direction. Let us think a bit, as input we have an path element (which is linked to a cell and direction), a cell that know how the beam exits and a grid which contains all the cells. 


[[[
LaserPathElement>>nextElementIn: aGrid

	|  direction newLocation nextCell |
	direction := GridDirection directionFor: (self cell exitFor: self entrySide).
	newLocation := self cell gridLocation + direction vector.
	nextCell := aGrid at: newLocation.
	^ nextCell isNil
		ifTrue: [ nil ]
		ifFalse: [ self class cell: nextCell entrySideDirection: direction ] 
]]]


There is a dependency on some behavior in ==Grid== that is expected here. When a location is given that would be invalid for the grid, because of indexes like 0 or ones larger than the number of rows or columns. The expectation here is that the cell found would be set to nil. We should go back to the Grid code and ensure we handle this. Just add the "ifAbsent: []" code.


[[[
Grid>>at: aPoint
   ^ self cells at: aPoint ifAbsent: []
]]]

SD: Add a test


SD: Add more tests



  ==GridDirection directionFor: (self cell exitFor: self entrySide).== can be turned into cell method.












!! About Encodings Default Values and Shared Pools

Note that there are other ways in Pharo to define constant: Shared pools 


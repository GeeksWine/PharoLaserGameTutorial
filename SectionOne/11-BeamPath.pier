
% Left out "Leaving Notes in Your Code" from original,
% http://squeak.preeminent.org/tut2007/html/035B.html 
% http://squeak.preeminent.org/tut2007/html/035C.html 

! Leaving Notes in Your Code

http://squeak.preeminent.org/tut2007/html/035B.html 

@@todo BTC-2014-07-06 Is this section of original tutorial left out on purpose?


! Improving Our Debugging Context

% This section is new.

Dealing with a ==Grid== in the debugger is a bit a pain because we don't yet have a graphical representation of it. Also when graphical representations break, they can't be used to debug themselves.  So its useful to have a textual representation for observing the a ==Grid's== structure. 
The system had this convention of asking objects for their ==printString==.   Following this convention will help us debug and observe how the system it is working. 

Here is a test showing the behavior we want to start with, for an empty grid. For now we use ' x ' to help ensure the character well centered. Now pay attention that spaces are representated differently between text editors, so you may have a different look.

% BTC-2014-07-08 Ahh... Now I guess why the default grid size was 
% earlier changed from the original 1x1 to 5x5. And I had changed it 
% 3x3 without knowing its impacted here. 
% Well my 3x3 change was already integrated, so I propogate this here.
[[[
GridTest>>testTextualRepresentationEmptyGrid

	self assert: Grid new printString = 
'
| x | x | x |
| x | x | x |
| x | x | x |
'
]]]

The ==printString== method ends up calling its object's ==printOn:== method to generate the textual representation.  Below is one possible implementation. 
Again try to define it alone and follow our definition if you encounter
difficulties.  Note the common practice of putting a test expression in 
comments the top of the method, which you can select and ''Inspect''.

@@dothis On the class ==Grid== define the method ==printOn:== in the  'printing' protocol. 

% BTC-2014-07-06 Leaving a trailing space on each line (per previous code)
% is awkward and non-inutitive, and hard to capture in a printed page.
% Its better to be more explicit by using ==space==. 
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			aStream
				space;
				nextPutAll: 'x';
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]
% BTC-2014-07-06 aCol & aRow not suitable var names since Col and Row are not classes?

Run the test.  Now formatting the spaces exactly to satisfy the test can 
be tricky, so you might get a "TestFailure: Assertion failed" error.  
In the debugger, inspect the line ==Grid new printString== to investigate.
Actually since this formatting is not really critical here, you might be 
pragmatic and paste the result of that inspection into ==testTextualRepresentationEmptyGrid==. 
% Otherwise it will be annoying that the reader works hard to get the 
% above test working with the 'x', and then need to replace it with space.


Once that is working, we would like the grid to display each type of cell. 
Do you have an idea how we could do that?
May be we could ask each cell its visual representation character instead of 
the =='x'== placeholder. We'll define a method named
==stringRepresentation== on the cell classes. We decided to use a string 
rather than a character to provide more flexibility to quickly change the
representation of a cell. Using a string implies that the representation 
can have a variable length.

% BTC-2014-07-06 I feel in this case the test is better written
% after-the-fact.  Is that really-bad?  I think its advtangeous to not
% be so proscriptive to the reader on Test Driven Development
% that they feel locked in.  Let them see a bit of flexibility. 


@@dothis Update the ==printOn:== method as follows, and add the placeholder ==stringRepresentation== ('printing' procotol).
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			| cell |
			cell := self at: col@row.
			aStream
				space;
				nextPutAll: cell stringRepresentation;
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]

[[[
Cell>>stringRepresentation
	^ 'x'.
]]]

Check you test is still green. 

@@dothis Now add ==stringRepesentations== for the specific cell types, and modify/add tests to suit.

[[[
BlankCell>>stringRepresentation
	^ ' '   "There is one space character in the string."
]]]
[[[
GridTest>>testTextualRepresentationEmptyGrid
	"There are 3 space characters between the bars."
	self assert: Grid new printString = 
'
|   |   |   |
|   |   |   |
|   |   |   |
'  
]]]


[[[
TargetCell>>stringRepresentation

	^ 'o'
]]]
[[[
GridTest>>testTextualRepresentationGridWithTarget

	| grid |
	grid := Grid new  at: 3@1 put: TargetCell new.  
	self assert:  grid printString = 
'
|   |   | o |
|   |   |   |
|   |   |   |
'
]]]



[[[
MirrorCell>>stringRepresentation

	^ leansLeft ifTrue: ['\'] ifFalse: [ '/']
]]]
[[[
GridTest>>testTextualRepresentationGridWithMirror

	| grid |
	grid at: 1@1 put: MirrorCell leanLeft.
	grid at: 2@1put: MirrorCell leanRight.
	self assert:  grid printString = 
'
| \ | / |   |
|   |   |   |
|   |   |   |
'
]]]

Now since ==GridTest>>generateDemoGrid== is already defined, we can use that for  final test to validate overall behavior.

@@dothis Define a test for the textual representation of the demo grid.

[[[
GridTest>>testTextualRepresentation

	self assert: self generateDemoGrid printString = 
'
|   |   |   | / | o |
| / |   |   |   | \ |
|   | \ | / |   | \ |
|   | \ | \ |   |   |
| / |   |   | / |   |
'
]]]

@@todo Notice that it would be good to have also a class to represent ==StartingCell== like that we could add behavior to it.  
@@todo BTC-2014-07-06 Maybe, but need to finish the rest of the port, and see how it would fit. Maybe just advise reader to try it themselves.


! Laser Beam Path 

Now we are ready to work on how to represent the laser beam and its path 
through the cells. Before jumping into the code, lets think a bit about what
 we'll need. We need to have a collection of elements describing the beam 
(that later will likely form the basis of the beam's visual representation).
 When the beam exits a cell we need to ==determine/know== which cell it
 will enter next.
This means that we need a way to handle the cell locations and the interpretation of the direction based on such location. 



!! Laser Path Element 

% http://squeak.preeminent.org/tut2007/html/036.html

When we consider the path of the laser beam through the grid, it's
pretty easy to imagine the path as an ordered collection. The elements
in the path may not be strictly cells, since as well as knowing the
type of cell, we need to know how the laser is entering each
cell. So we need a path element that wraps together both pieces of information.  
Later we can work out what "questions" we want to ask of this element.

Lets get started by defining a new class named ==LaserPathElement== to
represent a path element. Each element will bind an entry side to a
given cell, so we needing an instance variable for each to fully
characterize an element. 

@@dothis Define new class ==LaserPathElement==.

[[[
Object subclass: #LaserPathElement
	instanceVariableNames: 'cell entrySide'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Add its class comment.
[[[
"I define one step in the path of a laser beam, which associates a cell
with which side the beam enters it."
]]]

@@dothis Create the four accessors ==cell, cell:, entrySide, entrySide:==.

!! Grid support

We'll need somewhere to hold our collection of path elements.
Conceptually,  the laser beam operates on the grid, so we'll store it
there.  We'll work out initialization in a few minutes.

@@dothis Go back to ==Grid== to add an instance variable for the laser beam path.  

[[[
Object subclass: #Grid
	instanceVariableNames: 'cells laserIsActive numberOfRows numberOfColumns laserBeamPath'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Create accessors ==laserBeamPath, laserBeamPath:==.

We also need to specify the starting cell when the laser is
activated. This will always be the cell in the bottom left corner, 
so for now we hardcode it.

@@dothis Define a method on ==Grid== to answer the starting cell.

[[[
Grid>startingCell

	^ self at: (1@ self numberOfRows)
]]]


!! Adding Location to Cell

% http://squeak.preeminent.org/tut2007/html/037.html

To help compute the next cell from a given cell and direction we
need to enhance our cells. Each cell should store its own grid location.
This will make navigation and position calculations easier. Without this
stored location, if we had reference to a cell and wanted to know its
position, we would need to scan through the grid (a Dictionary) until 
we found the key referencing it, where the key is its position. 
Holding the location within the cell is easier and much faster. 


@@dothis To ==Cell== add instance variable ==gridLocation==. Also create accessors for this.

[[[
Object subclass: #Cell
	instanceVariableNames: 'activeSegments exitSides gridLocation'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

Now at what point should a cell's grid location be set?   Probably when
the cell is placed in the grid. 

@@dothis Modify ==Grid>>at:put:== to set the ==gridLocation:== of ==aCell==.

[[[
Grid>>at: aPoint put: aCell

	aCell gridLocation: aPoint.
	self cells at: aPoint put: aCell.
]]]





!! Direction Vectors

% http://squeak.preeminent.org/tut2007/html/038.html

@@todo BTC-2014-07-14 Rather than this section split the ==LaserPathElement== material, I feel inclined to move it forward as its own chapter - but will wait until later to guage the overall structure of the book. 

!!!Requirement 

So far we've been using two kinds of systems to describe cell locations
and laser beam directions. Cell locations have been described 
numerically, of form ==x\@y== to describe where cells are located 
within the grid (representing the column and row respectively).  
Laser beam directions have been described symbolically, 
using ==\#north==, ==\#east==, ==\#south== and ==\#west==. 
What we need is a way to combine these concepts for when we start 
to navigate our laser beam across the grid and through cells. 

@@todo SD: should be better explained. It took me a while to understand it. BTC: I've had a go, what do you think?

Let us think about a solution: Consider for example that moving east or 
south in the grid increases the ==x== or ==y== coordinates respectively.
If we are at 5\@5, then going east should take us to 6\@5. 
Similarly going south should take us to 5\@6. Effectively the 
symbolic direction needs to be mapped to a numeric vector that can 
be applied to a grid location.  
We can define a simple test for this to clarify our thinking. 

@@dothis Define classes ==GridDirection== & ==GridDirectionTest==, and method ==testDirectionVectors==.
[[[
TestCase subclass: #GridDirectionTest
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Tests'
]]]
[[[
GridDirectionTest>>testDirectionVectors
	| vector |
	vector := GridDirection vectorFor: #east.
	self assert: vector = 1 @ 0.
	
	vector := GridDirection vectorFor: #west.
	self assert: vector = -1 @ 0.

	vector := GridDirection vectorFor: #south.
	self assert: vector = 0 @ 1.

	vector := GridDirection vectorFor: #north.
	self assert: vector = 0 @ -1.
]]]

When asked, approve the unknown method ==vectorFor:==. 
Then for '' 'Unknown variable: GridDirection' '' 
you should '' 'Define new class' '' as follows... 
(Note, change the ==category:== of the given class definition template.)

[[[
Object subclass: #GridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Add a class comment to ==GridDirection==.
[[[
I map symbolic directions to numeric vectors for the beam path across the grid.
]]]



!!! A scent of code

Now for the supporting code. The above test sends the 
==vectorFor:== message direct to the ==GridDirection== class, 
so this will need to be a class-method 
(so ensure the class-side checkbox is selected). 
A first reflex might be to use a bunch of conditional statements 
like a traditional case statement.

@@dothis Add class method ==vectorFor:== using a traditional case-structure. 

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	(gridDirectionSymbol = #east)   ifTrue: [ ^  1 @ 0  ].
	(gridDirectionSymbol = #west)   ifTrue: [ ^ -1 @ 0  ].	
	(gridDirectionSymbol = #south)  ifTrue: [ ^  0 @ 1  ].
	(gridDirectionSymbol = #north)  ifTrue: [ ^  0 @ -1 ].	
]]]

Run our tests to ensure everything is good. Oops! 
We have a coding error as shown in Figure *FailedTestGridDirectionTest*. 
+Failed test testDirectionSelection>file://figures/11-testFail-needsBrackets.png|width=60|label=FailedTestGridDirectionTest+

+The message '@' was sent to a boolean>file://figures/11-testFail-needsBrackets-debugger.png|width=60|label=MNUFalse+

Clicking on the failed test brings up the debugger shown in  Figure
*MNUFalse*, which describes the problem as  '' "Message Not Understood:
False>>@" ''. This indicates the '==@=='  message was sent to an
instance of ==False==, and indeed this doesn't define the '==@=='
method. But this is strange!  We've previous used positions like
==1@0==, where the '==@==' message is sent to the number '==1=='
object. Inspecting the ==vector== variable shows it holds the expected
value of ==1@0==, but the comparison is not working.  

What is happening is that =='='== and =='@'== are both binary messages,
and so are of the same precedence. Hence these are evaluated strictly
left to right.   We require parenthesis to ensure the =='@'== message
(which creates a Point object for our position) is evaluated before the
comparison message =='='==.

@@dothis Edit the ==vectorFor:== method in the debugger, adding parenthesis around each position. 

% http://squeak.preeminent.org/tut2007/html/039.html

[[[
GridDirectionTest>>testDirectionVectors
	| vector |
	vector := GridDirection vectorFor: #east.
	self assert: vector = (1 @ 0).
	
	vector := GridDirection vectorFor: #west.
	self assert: vector = (-1 @ 0).

	vector := GridDirection vectorFor: #south.
	self assert: vector = (0 @ 1).

	vector := GridDirection vectorFor: #north.
	self assert: vector = (0 @ -1).
]]]

After accepting the changes, observe that the method restarts and you 
can continue execution. Try stepping '' 'Over' '' the remainder of the 
method. 

Re-run the tests. They should now all be green.



!!! A bettter scent of code

Reviewing our quick and dirty first implementation of ==vectorFor:==,
this works but has a bad smell object-oriented wise, and we
can do better. As Valloud says, "a high frequency of 
[conditional statements] suggests that distinctions which might have
been possible at design-time are being drawn at run-time. But if
distinctions were drawn at design time in the form of classes, then it
would not be neccessary for the running program to repeatly rediscover
what was known by the developers."  [1]

Following this philosophy, we reimplement our case-structure in an
object-oriented manner. Imagine each direction is represented by a
different object that can answer the required vector. In Pharo, class
descriptions are objects too. We can define a class per direction which
binds together the symbolic/numberic mapping as class-methods.  Using
classes rather than instances allows us to refer to the directions
as global identifiers. 

These classes will be similar, so we will use our
existing ==GridDirection== as their superclass, to hold any common
behaviour that may arise. You should end up with an inheritance
hierarchy like that shown in *RowDebugPreview*.

@@todo SD add a diagram explaining how to use Direction

@@dothis Define a class per direction.

[[[
GridDirection subclass: #EastGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
	
	"I specify the delta to move east."
]]]

[[[
GridDirection subclass: #WestGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move west."
]]]

[[[
GridDirection subclass: #NorthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move north."
]]]

[[[
GridDirection subclass: #SouthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move south."
]]]


@@todo BTC-2014-07-07 Stef, what do you think about specifying the class comments as above?  We can describe this convention in the introduction. Separating out class comments for each of the above is more verbose and a bit awkward.


+A hierarchy of directions.>file://figures/11-GridDirection.pdf|width=60|label=RowDebugPreview+

% http://squeak.preeminent.org/tut2007/html/038a.html

Now we can define the polymorphic behaviour of each direction class. 
Each class should know its:
- ==directionSymbol== - the symbol encoding the direction.  
- ==vector== - the numeric delta to move from one cell to the next

@@dothis Define the following eight class-methods (then try them out in a Workspace as described above.)

[[[
EastGridDirection class>>directionSymbol
	^ #east

EastGridDirection class>>vector
	^ 1 @ 0
]]]
[[[
NorthGridDirection class>>directionSymbol
	^ #north

NorthGridDirection class>>vector
	^ 0 @ -1
]]]
[[[
SouthGridDirection class>>directionSymbol
	^ #south

SouthGridDirection class>>vector
	^ 0 @ 1
]]]
[[[
WestGridDirection class>>directionSymbol
	^ #west

WestGridDirection class>>vector
	^ - 1 @ 0
]]]

Since we have defined these as class-methods, we are able to use
them like this (for example in a Workspace)... 

[[[
EastGridDirection directionSymbol.  " --> #east "

EastGridDirection vector.   " --> (1@0) "
]]]

Above each class defines a single case of our case-structure.  Now we
need to be define how to detect which direction-class matches a given
direction-symbol. Here ==self subclasses== returns all of our cases, and
the ==detect:== message iterates through these passing each into the
block variable ==case== until the block evaluates to true.  At that
point the current value of ==case== is returned. Observe how its easy
for the run-time to query the class hierarchy, and how the classes can
themselves be passed around like objects.

@@dothis Define a method to map a direction-symbol to its direction-class, as well as a test for this.

[[[
GridDirection class>>directionFor: aDirectionSymbol
	^ self subclasses detect: [ :case | case directionSymbol = aDirectionSymbol ]
]]]

% http://squeak.preeminent.org/tut2007/html/039.html

[[[
GridDirectionTest>>testDirectionSelection
	self assert: NorthGridDirection = GridDirection directionFor: #north.	
	self assert: EastGridDirection  = GridDirection directionFor: #east.
	self assert: SouthGridDirection = GridDirection directionFor: #south.	
	self assert: WestGridDirection  = GridDirection directionFor: #west.
]]]

Run the tests to check this works.   

Now we are ready to reconsider our original ==vectorFor:== method, which
is repeated here for convenience. Instead of this traditional
case-structure, we now determine the applicable direction-class and
just ask that for its ==vector==.

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	(gridDirectionSymbol = #east)   ifTrue: [ ^  1 @ 0  ].
	(gridDirectionSymbol = #west)   ifTrue: [ ^ -1 @ 0  ].	
	(gridDirectionSymbol = #south)  ifTrue: [ ^  0 @ 1  ].
	(gridDirectionSymbol = #north)  ifTrue: [ ^  0 @ -1 ].	
]]]

@@dothis Modify ==vectorFor:== to an object-oriented form.

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	^ (self directionFor: gridDirectionSymbol) vector.	
]]]

Re-run the tests to check they are still green.  Well actually, they
could just be green because our tests don't cover this method.  You
might double-check this is indeed a neutral refactoring, by returning
''nil'' from ==vectorFor:== to confirm this breaks some test. Being able
to break things reliably is a useful check point. Then return
==vectorFor:== to its proper form.

Once all the tests pass, it is a good time to publish your code.


!!! Discussion

% http://squeak.preeminent.org/tut2007/html/048A.html

So we have seen both the traditional and object-oriented approach to a
case-structure.  So what is gained by the latter? There are two
things: maintainability and performance. 

For maintainability, consider a scenario needing a ==symbolFor:== method
to map vector directions back to symbols. The traditional form 
might add this...

[[[
GridDirection class>>symbolFor: gridDirectionVector
	(gridDirectionVector = ( 1 @ 0 ) )  ifTrue: [ ^ #east ].
	(gridDirectionVector = (-1 @ 0 ) )  ifTrue: [ ^ #west ].	
	(gridDirectionVector = ( 0 @ 1 ) )  ifTrue: [ ^ #south ].
	(gridDirectionVector = ( 0 @ -1 ) ) ifTrue: [ ^ #north ].	
]]]

However this essentially duplicates the hardcoded information in
==vectorFor:==, creating a burden to manage consistency between the two
methods. Imagine that the requirement to handle diagonal directions is
added, needing updates to both ==symbolFor:== and ==vectorFor:==. Then
later, requirements change again to reverse the east-west vector
convention. Having the data of the forward and reverse mappings
coded apart raises the risk of error.

In its object-oriented form, each forward and reverse mapping is coded
in same place, local to its own dedicated class object.  The existing
mapping of previously defined ==GridDirection== subclasses can be
reused, so our ==symbolFor:== method would look like this...

[[[
GridDirection class>>symbolFor: gridDirectionVector 
		^ (self directionForVector: gridDirectionVector) symbol.
]]]
[[[
GridDirection class>>directionForVector: aDirectionVector
	^ self subclasses detect: [ :case | case vector = aDirectionVector ]
]]]

A requirements change that adds diagonal directions now does not change
==symbolFor:== nor ==vectorFor:==. Both methods benefit from defining
each new mapping once like so...

[[[
SouthEastGridDirection>>directionSymbol
	^ #southeast

SouthEastGridDirection class>>vector 
	^ 1@1
]]]

In addition, with the traditional case-structure symbols like ==#north==
end up scattered throughout the code. When we inspect these in the
debugger at run-time, they hold no information about their symbol/vector
mapping.  However when real objects like ==NorthGridDirection== are used
throughout the code in place of symbols, inspecting these at run-time
provides access to the symbol/vector mapping.

Now you may be wondering how a default values is provided by an
object-oriented case-structure. This is handled where we iterate to
detect a matching case, changing from ==#detect:== to
==detect:ifNone:==. For example, for an unknown direction-symbol the
default might be  to stay in the same position, as follows...

[[[
GridDirection class>>directionFor: aDirectionSymbol
	^ self subclasses 
	          detect: [ :case | case directionSymbol = aDirectionSymbol ]
            ifNone: [ self ].  
]]]

[[[
GridDirection class>>vector
	^ 0@0
]]]


With regard to performance, consider that with diagonal directions the
traditional case-structure has eight conditional statements, half of
which need to be evaluated on average each time a direction-symbol like
#north needs to be used as direction-vector.  Alternatively, an
object-oriented case-structure using real objects like
==NorthGridDirection==, requires only a single method call to ==vector==
each time a direction-vector is required. Indeed, Valloud says "If you
need to improve performance, classes and polymorphism are some of your
most powerful allies because they can make it so that the run-time does
not need to spend any time whatsoever recreating known [design-time]
information."


!! Back to the Laser Beam Path

% http://squeak.preeminent.org/tut2007/html/040.html

Now we are ready to work further on our laser path elements. Let us
begin by defining a convenience method for instance creation. Do you
have any idea how to proceed? Remember that our ==LaserPathElement== has
two instance variables, and it will be useful to initialize these at the
same time that the object is created. 

@@dothis Define an instance-creation class-method to initialize all instance variables.

[[[
LaserPathElement  class>>cell: aCell entrySide: aDirectionSymbol 

	| element |
	element := self basicNew.
	element 
		cell: aCell;
		entrySide: aDirectionSymbol.
	^ element
]]]


@@todo SD: add a test. BTC: I'll come back to do this - since it won't upset the flow to leave it for now.

@@todo BTC-2014-07-14 Is the next bit needed yet? Maybe the original tutorial does this later already.

We can also add another method taking a direction instead than a symbol. Objects are always more powerful than mere data so we should favor their use. 

[[[
LaserPathElement class>>cell: aCell entrySideDirection: aDirection

	^ self cell: aCell entrySide: aDirection directionSymbol
]]]


@@todo SD: add a test

Some key functionality we require is given a path element, determine the
next cell on grid. Here we will clearly see the importance of direction.
Let us think a bit... a path element links an entry direction to a cell,
which can determine the exit direction and next location.  A grid lookup
of this next location gives us the next cell.  The exit direction
becomes the next cell's entry direction, which together give us our next
path element.  So from a path element and a grid, we can determine the
next path element.

@@dothis Define a method for a path element to use a grid to determine the next path element. 

[[[
LaserPathElement>>nextElementIn: aGrid

	| directionSymbol direction nextLocation nextCell |
	directionSymbol := self cell exitSideFor: self entrySide.
	direction := GridDirection directionFor: directionSymbol.
	nextLocation := self cell gridLocation + direction vector.
	nextCell := aGrid at: nextLocation.
	^ nextCell isNil
		ifTrue: [ nil ]
		ifFalse: [ self class cell: nextCell entrySideDirection: direction ]
]]]

Now there is a dependency on some behavior in ==Grid== that is expected here. When a location is given that would be invalid for the grid, because of indexes like 0 or ones larger than the number of rows or columns. The expectation here is that the cell found would be set to nil. We should go back to the Grid code and ensure we handle this. Just add the "ifAbsent: []" code.


[[[
Grid>>at: aPoint
   ^ self cells at: aPoint ifAbsent: []
]]]

@@todo SD: Add some tests. BTC: I'll come back to do this - since it won't upset the flow to leave it for now.

@@todo SD: Maybe ==GridDirection directionFor: (self cell exitFor: self entrySide)== can be turned into cell method. BTC: Wait to see what the rest of the tutorial brings. It might do this already.


!! About Encodings Default Values and Shared Pools

@@todo BTC-2014-07-14 I don't see how this applies. What am I missing? Also, I don't think we should complicate the flow of the tutorial by introducing too many things that are "optional," since if the reader tries them they are out of sync with the tutorial.  I think its better to attack these later in some refactoring sections.

Note that there are other ways in Pharo to define constant: Shared pools

!! References

[1] Valloud, A. ''A Mentoring Course on Smalltalk'' 



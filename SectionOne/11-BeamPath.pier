! Laser Beam Path 

We are ready to work on the way to represent the laser beam and its path through the cells. Before jumping in the code let us think a bit about what we will need. We need to have a collection of elements describing the beam (probably such elements will be the basis to represent visually the beam when 
we will start adding visual elements). When the beam will exist to the east of a given cell we will need to know to which other cell it will enter.
This means that we will need a way to handle the cell locations and the interpretation of the direction based on such location. 




!! Laser Path Element 
When we consider the path of the laser beam through the grid, it's pretty easy to imagine the path as an ordered collection. The elements in the path may not be strictly cells since we will need to be aware how the laser is entering each cell. Let us get started by defining a new class named ==LaserPathElement== to represent path element. 

Such element is bound to a given cell and an entry side, therefore we add the following instance variables to fully characterize an element. 

[[[
Object subclass: #LaserPathElement
	instanceVariableNames: 'cell entrySide'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

Add the corresponding accessors. 


!! Adding a Class Comment

So let us first add a class comment, for example as follows

[[[
I represent the part of a laser beam that is associated with a cell and with an entry side. 
]]]

!! Back to the Grid

Go back to the Grid and add an instance variable for the laser beam path and then add its accessors. We'll work out initialization in a few minutes.

[[[
Object subclass: #Grid
	instanceVariableNames: 'cells laserIsActive numberOfRows numberOfColumns laserBeamPath'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

We also need a method to answer the starting cell when the laser is activated. This will always be the cell in the bottom left corner.

[[[
Grid>startingCell

	^ self at: (1@ self numberOfRows)
]]]


!! Adding Location to Cell

To be able to compute from a cell and a direction its neighbouring cell we will enhance the cells. Each cell should store its own grid location. This will make navigation and position calculations easier. Without the stored location, we can still find specific cell locations within the grid by scanning through all the cells until we find the identical one we are looking for, then we would answer that cell's key (a position) in the cell dictionary. Holding the location within the cell is easier and much faster. 


Add the ==gridLocation== instance variable and its accessors.

[[[
Object subclass: #Cell
	instanceVariableNames: 'activeSegments exitSides gridLocation'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]


We should not forget to set the grid location to the cells when the grid adds the cell to its own structure. 
We modify then the method ==at:put:== of the class ==Grid== as follows:

[[[
Grid>>at: aPoint put: aCell

	aCell gridLocation: aPoint.
	self cells at: aPoint put: aCell.
]]]





!! Handling Directions

We've been using two kinds of systems to describe cell locations and laser beam direction. In one situation we use ==x\@y== (column x, row y) objects to describe where cells are located within the grid. We describe laser beam direction with the symbols ==\#north==, ==\#east==, ==\#south== and ==\#west==. We need a way to allow us to combine these concepts when we start to navigate our laser beam across the grid and through cells. 

Let us think about a solution: what would be good is to have objects that capture that for example going east is increasing of one the ==x== coordinates. If we are in cell ==5\@5== going east we should get to the cell ==6\@5==. Similarly going south is changing the y coordinates. 

A first reflex could be to write some conditions but we can do better. Indeed we do not want to have to have tests and conditionals and we can imagine that we can get different objects representing different directions and each one answering the delta that should be applied to get from one cell to the other one.

SD: should be better explained. It took me a while to understand it.

SD add a diagram explaining how to use Direction

For this we will create classes to represent the different direction and we will start by defining a common superclass named ==GridDirection==. We will then define a couple of messages on these classes. 

[[[
Object subclass: #GridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

And we can add a comment.

[[[
I represent directions for the beam path accross the grid cells.
]]]

+A hierarchy of directions.>file://figures/11-GridDirection.pdf|width=60|label=RowDebugPreview+

Then we can define one suclass for each direction as follows

[[[
GridDirection subclass: #EastGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #WestGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #NorthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

[[[
GridDirection subclass: #SouthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

You should obtain an inheritance hierarchy as described in *RowDebugPreview*.





Now for each subclasses, we can define some messages: the ==vector== which returns the delta from the cell to the direction and ==directionSymbol== which returns the symbol encoding the direction. 

For example we want to write 

[[[
SouthGridDirection directionSymbol
  -> #south
]]]


[[[
SouthGridDirection vector 
  -> 0@1

]]]

Since we want to ask the class for its encodings, we will define ''class'' methods on each subclasses as below.

[[[
EastGridDirection class>>vector
	^ 1 @ 0

EastGridDirection class>>directionSymbol
	^ #east
]]]




[[[
NorthGridDirection class>>vector
	^ 0 @ -1

NorthGridDirection class>>directionSymbol
	^ #north
]]]


[[[
SouthGridDirection class>>directionSymbol
	^ #south

SouthGridDirection class>>vector
	^ 0 @ 1
]]]


[[[
WestGridDirection class>>directionSymbol
	^ #west

WestGridDirection class>>vector
	^ - 1 @ 0
]]]



Now we can define a method named ==directionFor:== returning the class of the direction associated to directiondescribed by a symbol. 

[[[
GridDirection directionFor: #east
-> EastGridDirection
]]]

Here is the class method definition:

[[[
GridDirection class>>directionFor: aDirectionSymbol

	^ self subclasses 
			detect:  [ :cls | cls directionSymbol = aDirectionSymbol ]
]]]





!! Adding Some Tests

Now we need a unit test for the grid direction vector code. So let us add the new class ==GridDirectionTestCase== is a subclass of ==TestCase== of course.

[[[
TestCase subclass: #GridDirectionTest
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Tests'
]]]


[[[
GridDirectionTest>>testDirectionSelection
	| direction |
	direction := GridDirection directionFor: #north.
	self assert: direction = NorthGridDirection.
	self assert: direction vector = ( 0 @ -1 ).
	
	direction := GridDirection directionFor: #east.
	self assert: direction = EastGridDirection.
	self assert: direction vector = ( 1 @ 0 ).
	
	direction := GridDirection directionFor: #south.
	self assert: direction = SouthGridDirection.
	self assert: direction vector = ( 0 @ 1 ).
	
	direction := GridDirection directionFor: #west.
	self assert: direction = WestGridDirection.
	self assert: direction vector = ( -1 @ 0 ).
]]]


Once all the tests pass, it is a good time to publish your code.






!!! About Shared Pools

Note that there are other ways in Pharo to define constant: Shared pools 

